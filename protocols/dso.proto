# Tektronix DSO 4000

InTerminator = LF CR;
OutTerminator = CR LF;
ReplyTimeout = 2000;
ReadTimeout = 5000;
LockTimeout = 8000;

# Setup, either on-demand when processed, but also automatically when connecting:
# Do not echo header in reply, but if you do, then use full name
# Get 10000 samples, 1 byte per sample
setup
{
  out ":HEAD OFF;:VERB ON;:DAT:STAR 1;:DAT:STOP 10000;:DAT:WID 1;:DAT:ENC ASCII;";
  @init
  {
    out ":HEAD OFF;:VERB ON;:DAT:STAR 1;:DAT:STOP 10000;:DAT:WID 1;:DAT:ENC ASCII;";
  }
}

# Binary curve reply:
# '#5'    : 5 decimals for data size follow
# '10000' : Number of data points
# <binary>: 10000 signed bytes of data
# CR/LR   : 2 more bytes for end of line
#
# Protocol based on help from Dirk Zimoch:
# Parse '#510000' verbatim,
# then waveform record repeats %r for NELM,
# followed by LF CR.
# Cannot use 'Terminator' because <binary> could contain anything.
# So stop after 'MaxInput'.
#curve1
#{
#  InTerminator="";
#  MaxInput=10009;
#  out ":DAT:SOU CH1;:CURV?";
#  in "#510000%1r\n\r";
#}

# Using ASCII, the Terminator ends a line, less chances of getting out of step
Separator = ",";
curve1
{
  out ":DAT:SOU CH1;:CURV?";
  in "%d";
}

curve2
{
  out ":DAT:SOU CH2;:CURV?";
  in "%d";
}

curve3
{
  out ":DAT:SOU CH3;:CURV?";
  in "%d";
}

curve4
{
  out ":DAT:SOU CH4;:CURV?";
  in "%d";
}


# Info is returned as "xxx".
# Use regex to get just xxx, not quotes
info1
{
  out ":DAT:SOU CH1;:WFMOutpre:WFID?";
  in '%.1/"(.*)"/';
}

info2
{
  out ":DAT:SOU CH2;:WFMOutpre:WFID?";
  in '%.1/"(.*)"/';
}

info3
{
  out ":DAT:SOU CH3;:WFMOutpre:WFID?";
  in '%.1/"(.*)"/';
}

info4
{
  out ":DAT:SOU CH4;:WFMOutpre:WFID?";
  in '%.1/"(.*)"/';
}

xincr
{
  out ":WFMOUTPRE:XINCR?";
  in "%f";
}

mult1
{
  out ":DAT:SOU CH1;:WFMOutpre:YMUlt?";
  in "%f";
}

mult2
{
  out ":DAT:SOU CH2;:WFMOutpre:YMUlt?";
  in "%f";
}

mult3
{
  out ":DAT:SOU CH3;:WFMOutpre:YMUlt?";
  in "%f";
}

mult4
{
  out ":DAT:SOU CH4;:WFMOutpre:YMUlt?";
  in "%f";
}

